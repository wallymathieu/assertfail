---
layout: post
title: Is mainstream programming in a dead end?
date: 2019-01-27T21:02:53+01:00
---

While working with a more senior coworker (around 2009), he tried to inform me about about what is needed in order to move forward in the the age of limited single core processor speed (but increasing number of processor cores). I was quite sceptical of his claims. In another company, we had practised some of the teachings and felt the pains. I didn't feel that you could develop without spending inordinate amount of time.

I was too focused on procedural programming (and object oriented, procedural oriented programming languages like Java, C# et.c.). Once I started remember some of the languages taught in school (and started seeing commercial applications of these), I realised that the problem wasn't the concepts themselves, but that programming languages show some sort of [Sapir-Whorf](https://en.wikipedia.org/wiki/Linguistic_relativity) effect. Natural languages don't share the rigidity of constructed programming languages. By forcing programmers to think in rigid ways, you can greatly influence their thoughts (while the same cannot be said about natural languages).

Why does this matter? If you look at mainstream programming tools (based on ads for jobs in Sweden) you will find that most mainstream programming languages falls into a few broad categories. I will make one arbitrary categorisation:

 - Java, C# (GC)
 - C, C++
 - Python, Javascript (script)

Note that all of these favour single threaded style of execution.

If you read [Programming paradigms for dummies: what every programmer should know](https://blog.acolyer.org/2019/01/25/programming-paradigms-for-dummies-what-every-programmer-should-know/) you will note that most the concepts are unfamiliar to the working programmer.

We have seen some shift in frameworks embracing concepts

 - type system
 - promise
 -

However, mainstream programming easily goes down the cargo cult train. We see some